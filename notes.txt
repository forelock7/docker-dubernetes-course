# Create image base on 'node' image (latest version), pulling it from hub.docker
FROM node

# Change working dir to '/app'(create '/app' and go inside it), which means that all further commands will be executed from '/app'
WORKDIR /app

# Optimization for executing layers. First install all depandancies then coppy all code source in case code would be changed
COPY package.json /app

# Run command
RUN npm install

# Copy all files/folders from '.' path (root, where Dockerfile exists) to '.' path (root) in container
# COPY . .
# if WORKDIR set up we can use either 'COPY . .' or 'COPY . ./' or 'COPY . /app'
COPY . /app

# Let docker know that when container starts we want to expose port 80 to local machine, which runs this contaier
# It just clarifes port, but actually does nothing
# EXPOSE 80

# Set some default arguments
ARG DEFAULT_PORT=80

# Set environmental variable and default value
ENV PORT $DEFAULT_PORT

# Use environmental variable PORT
EXPOSE $PORT

# Anonymous volume. It will be deleted if remove container. Can be provided during 'docker run -v /app/feedback'  
# VOLUME [ "/app/feedback" ]

# It starts app during image creation/building, but it's inncorrect because image is just template. Do not do it!
# RUN node server.js

# It runs command only during start of container
CMD ["node", "server.js"]

----------------------------------------------------------------------------------------------------------------
- Build docker image base Dickerfile in root
docker build .

- Run docker container from image. You can use only few first ID sympols like "f5dffbb96bb3ad76ef4c7"
docker run f5dffbb96bb3ad76ef4c781f96db877dd57d570ef672a77b6bb7e3651b9a32a2

- Get all running docker containers
docker ps

- Get all existing docker containers
docker ps -a

- Stop container by name
docker stop friendly_elion

- Create NEW container and Expose/Publish(-p) local port 3000 (which port shpould be accessable) with internal port 80 inside container
docker run -p 3000:80 ae4e16965ad800a7faa8f07d66148249fe68daa88344938616207a3b3e7fdbfb

- Docker caches all instruction(lines in Dockerfile). It re-builds only changed layer. Therefore it can re-builds faster second time than very first.
- If one layer changed, Docker re-executes this one and all following.
- Every instruction in an image creates a cacheable layer.

- Check available option for cirtain commands
docker COMMAND --help
docker build --help 

- Start existing container, which was stopped before. Do not need create new container(docker run ...) if you didn't change image.
docker start container_name_id

- Attached mode - default for 'docker run'. Listening output of container, for example consol output.
docker run image_id
docker start -a container_name_id
docker attach container_name_id

- Detached mode - default for 'docker start'. The process in terminal finishes immediately. The container is running in the background.
docker start container_name_id
docker run -d container_name_id

- See the last logs in container
docker logs container_name_id

- See the last logs and follow log output in container
docker logs -f container_name_id

- Allocate a pseudo-TTY and keep STDIN open even if not attached. So we can input something via console if app needs.
docker run -it e38a6e781747027fb1ceefe9fa

- Start container with open STDIN(--attach and --interactive)
docker start -a -i awesome_fermi

- Remove container, but you need to stop it before
docker stop container_name_id
docker rm container_name_1 container_name_2 container_name_3

- Get list of all images
docker images

- Remove images, but you need to remove container before
docker rmi e38a6e781747

- Remove all unused images
docker image prune

- Automatically remove the container (--rm) when it exits (in case below it will be removed after stoping)
- Actually usefull when you need to rebuild image after some changes
docker run -p 3000:80 -d --rm 138689ba4848
docker stop busy_moser

- Display detailed information on one or more images
docker image inspect 138689ba4848

- Copy file from local machine to docker container
docker cp dummy/file.txt container_name:/app/test

- Copy file from docker container to local machine
docker cp container_name:/app/test dummy/file.txt

- Run/Create container with name 'goalsapp'
docker run -p 3000:80 -d --rm --name goalsapp 138689ba48485b88d3b8befe3952a1aa

- Image tag: "<name>:<tag>". For example "node:12"
-t Name and optionally a tag (format: "name:tag")
docker build -t goals:latest .
docker run -p 3001:80 -d --rm --name goalsapp2 goals:latest

- Rename image name:tag 
docker tag nodeapp:latest forelock/node-hello-world:latest

- Push docker image to hub.docker.commands (create before repo on docker hub)
docker login
docker push forelock/node-hello-world:latest

- Pull image from hub.docker.com
docker pull forelock/node-hello-world

////////////////////////////////////////////////////////////////////////////////////////////
Section 3: Managing Data & Working with Volumes
////////////////////////////////////////////////////////////////////////////////////////////

- Get list of volumes
docker volume ls

- Anonymous volumes created in Dockerfile, but named volumes created during run container
docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback feedback-node:volumes

- Delete volume
docker volume rm VOL_NAME
docker volume prune

- Type of data storage: Volumes(Anonymous and Named - managed by docker) and Bind Mounts(Managed by you)
- check before resources are shared with docker(local dir should be shared - Docker Desktop/settings/resources
- Anonymous Volume: "-v /app/node_modules" - overides particular dirs (if their more specific) from Bind Mount to save something that was created during image building
+ 1) Created specifically for a single container
+ 2) Survives container shutdown / restart - unless --rm is used
+ 3) Can not be shared across containers
+ 4) Since it's anonymous, it can't be re-used for same container (even same image)
- Named Volume: "-v feedback:/app/feedback" - for saving results when we stop/remove containers.
+ 1) Created in general - not tied to any specific container
+ 2) Survives container shutdown / restart - removal via Docker clarifes
+ 3) Can be shared across containers
+ 4) Can be re-used for same container (across restarts)
- Bind Mount: "-v "/Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/5-data-volumes-01-starting-setup:/app""" - for using code outside container, helps us to update code and do not re-build image.
+ 1) Location on host file system, not tied to any sppecific container
+ 2) Survives container shutdown / restart - removal on host fs
+ 3) Can be shared across containers
+ 4) Can be re-used for same container (across restarts)
- In this case DO NOT NEED VOLUME instaraction in Dockerfile
docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/.../5-data-volumes-01-starting-setup:/app" -v /app/node_modules feedback-node:volumes

- Shortcuts:
macOS / Linux: -v $(pwd):/app
Windows: -v "%cd%":/app

- If we use some specific project like web-server on node.js, we might need to stop and start container again to apply some changes: use dependancy kind of "nodemon"

- Bind Mount Volume is in read/write mode. It can be made as read only by adding ':ro' to the end. So we exclude '/app/temp' and '/app/node_modules' from Bind Mount
docker run -d --rm -p 3000:80 --name feedback-app -v feedback:/app/feedback -v "/Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/5-data-volumes-01-starting-setup:/app:ro" -v /app/temp -v /app/node_modules feedback-node:volumes

- Create Named Volume
docker volume create feedback-files

- Get infor about volume:
docker volume inspect feedback-files

- Remove volume if unused (need to stop/remove container before)
docker volume rm feedback-files

- Remove all unused volumes
docker volume prune

- Mostly Bind Mount is not used in production. It just needed for development

- To ignore some files/dirs during 'COPY' instruction need to add them to '.dockerignore' file

- propagate env vars we can use '--env PORT=8000' or '-e PORT=8000 -e HOST=10.32.43.21' in case "ENV PORT 80; EXPOSE $PORT;" in Dockerfile
docker run -d --rm -p 3000:8000 --env PORT=8000 --name feedback-app -v feedback:/app/feedback -v "/Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/5-data-volumes-01-starting-setup:/app:ro" -v /app/temp -v /app/node_modules feedback-node:env

- '.env' file can be also created with env vars, but then you need to use '--env-file ./.env' if it's in root
docker run -d --rm -p 3000:8001 --env-file ./.env .....

- Build Arguments is used to set different values during build image (ARG DEFAULT_PORT=80; ENV PORT $DEFAULT_PORT; EXPOSE $PORT;)
docker build -t feedback-node:web-app .    (applied 80 port)
docker build -t feedback-node:dev-app --build-arg DEFAULT_PORT=8000 .  (applied 8000 port)

////////////////////////////////////////////////////////////////////////////////////////////
Section 4: Networking: (Cross-)Container Communication
////////////////////////////////////////////////////////////////////////////////////////////

- Coonection to WEB: Docker container can communicate with WWW without additional configuration

- Connection to Host: If you have locally DB, out of Docker, You should use in Docker instead of 'localhost': 'host.docker.internal'
- For instance: 'mongodb://host.docker.internal:27017/swfavorites'

- Connection to other contaier: just use ip and port of containers

- Get info about container:
docker container inspect mongodb

- Create network:
docker network create favorites-net

- Get all existing docker networks:
docker network ls

- Add containers to the same networ, you can replace ip by container name in code: "mongodb://mongodb:27017/swfavorites"
docker run -d --name mongodb --network favorites-net mongo
docker run --name favorites --network favorites-net -d --rm -p 3000:3000 favorites-node

- Docker Networks actually support different kinds of "Drivers" which influence the behavior of the Network.
- The default driver is the "bridge" driver - it provides the behavior shown in this module (i.e. Containers can find each other by name if they are in the same Network).
- The driver can be set when a Network is created, simply by adding the --driver option.
docker network create --driver bridge my-net
- Of course, if you want to use the "bridge" driver, you can simply omit the entire option since "bridge" is the default anyways.
- Docker also supports these alternative drivers - though you will use the "bridge" driver in most cases:
+ host: For standalone containers, isolation between container and host system is removed (i.e. they share localhost as a network)
+ overlay: Multiple Docker daemons (i.e. Docker running on different machines) are able to connect with each other. Only works in "Swarm" mode which is a dated / almost deprecated way of connecting multiple containers
+ macvlan: You can set a custom MAC address to a container - this address can then be used for communication with that container
+ none: All networking is disabled.
- Third-party plugins: You can install third-party plugins which then may add all kinds of behaviors and functionalities
- As mentioned, the "bridge" driver makes most sense in the vast majority of scenarios.

////////////////////////////////////////////////////////////////////////////////////////////
Section 5: Building Multi-Container Applications with Docker
////////////////////////////////////////////////////////////////////////////////////////////

- Multi-container 
docker run --name mongodb --rm -d -p 27017:27017 mongo
docker build -t goals-node .
docker run --name goals-backend --rm -d -p 80:80 goals-node
docker build -t goals-react .
docker run --name goals-frontend --rm -p 3000:3000 -it goals-react
docker network create goals-net
docker run --name mongodb --rm -d --network goals-net mongo
// change in backend code localhosts to docker container name and re-build images
// still need to publish port 80 because frontend will reach from not container, but from outside - browser
docker run --name goals-backend --rm -d -p 80:80 --network goals-net goals-node
docker run --name goals-frontend --rm -p 3000:3000 -it goals-react 

- Persist data after removing of mongodb
docker run --name mongodb -v data:/data/db -d --rm --network goals-net mongo

- Add authontification to DB, but before update code in backend "mongodb://max:secret@mongodb:27017/course-goals?authSource=admin"
- Remove volume for DB before
docker volume rm data
docker run --name mongodb -v data:/data/db -d --rm --network goals-net -e MONGO_INITDB_ROOT_USERNAME=max -e MONGO_INITDB_ROOT_PASSWORD=secret mongo
docker run --name goals-backend --rm -p 80:80 --network goals-net goals-node

- Run backend app with saving logs dir and possibility to change code on flight
docker run -v /Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/7-multi-01-starting-setup/backend:/app -v logs:/app/logs -v /app/node_modules --name goals-backend --rm -d -p 80:80 --network goals-net goals-node
- Add to dev dep 'nodemon', update start script and Dockerfile, re-build image and re-run container

- Set username/password as env variable
+ replace it in code by `mongodb://${process.env.MONGODB_USERNAME}:${process.env.MONGODB_PASSWORD}@mongodb:27017/course-goals?authSource=admin`
+ add env vars in Dockerfile: ENV MONGODB_USERNAME=root \ ENV MONGODB_PASSWORD=secret
+ rebuild image and re-run container
docker run -v /Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/7-multi-01-starting-setup/backend:/app -v logs:/app/logs -v /app/node_modules --name goals-backend --rm -d -e MONGODB_USERNAME=max -p 80:80 --network goals-net goals-node

- Run frontend app with possibility to change code on flight
docker run -v /Users/volodymyrchubenko/Documents/Courses/Docker-Kubernetes-Course/7-multi-01-starting-setup/frontend/src:/app/src --name goals-frontend --rm -p 3000:3000 -it goals-react

- To improve image building
+ Add '.dockerignore' file and add at least: node_modules, .git, Dockerfile

////////////////////////////////////////////////////////////////////////////////////////////
Section 6: Docker Compose: Elegant Multi-Container Orchestration
////////////////////////////////////////////////////////////////////////////////////////////

- One configuration File + Orchestration Commands (build, start? stop)
- Docker Compose works with Dockerfile
- Services (Containers):
+ Published Ports
+ Volumes
+ Env vars
+ Networks

- docker-compose version - https://docs.docker.com/compose/compose-file/compose-file-v3/

- Do not need specify network because docker compose provide that default network out of the box
